# -*- coding: utf-8 -*-
"""8-puzzle-problem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IYJDnxrKayxP17Lhp2RoD62e9WYTfB2z

# **BFS Approach**
"""

import numpy as np

def isSolvable(states: list[int])-> bool:
  inversion: int = 0
  for i in range(len(states)):
    for j in range(i + 1, len(states)):
      if states[i] > states[j] and states[j] != 0:
        inversion += 1
  return inversion % 2 == 0

def getMoves(state: list[int], visitedstates: list[int])-> list[list[int]]:
  emptyTileIndex = state.index(0)
  moves = []

  if emptyTileIndex not in [0, 1, 2]:
    moves.append('UP')
  if emptyTileIndex not in [6, 7, 8]:
    moves.append('DOWN')
  if emptyTileIndex not in [0, 3, 6]:
    moves.append('LEFT')
  if emptyTileIndex not in [2, 5, 8]:
    moves.append('RIGHT')

  possiblestates = []
  for move in moves:
    newstate = state.copy()
    if move == 'UP':
      newstate[emptyTileIndex], newstate[emptyTileIndex - 3] = newstate[emptyTileIndex - 3], newstate[emptyTileIndex]

    if move == 'DOWN':
      newstate[emptyTileIndex], newstate[emptyTileIndex + 3] = newstate[emptyTileIndex + 3], newstate[emptyTileIndex]

    if move == 'LEFT':
      newstate[emptyTileIndex], newstate[emptyTileIndex - 1] = newstate[emptyTileIndex - 1], newstate[emptyTileIndex]

    if move == 'RIGHT':
      newstate[emptyTileIndex], newstate[emptyTileIndex + 1] = newstate[emptyTileIndex + 1], newstate[emptyTileIndex]

    possiblestates.append(newstate)
  # return possiblestates
  states = []
  for state in possiblestates:
    if state not in visitedstates:
      states.append(state)
  return states

def solveByBFS(state: list[int]):
  target = [1,2,3,4,5,6,7,8,0]
  queue = []
  queue.append(state)
  visitedstates = []

  while len(queue) > 0:
    state = queue.pop(0)
    visitedstates.append(state)
    if state == target:
      return visitedstates

    moves = getMoves(state, visitedstates)
    for move in moves:
      if move not in visitedstates and move not in queue:
        queue.append(move)
  return None

state1 = [8,1,2,0,4,3,7,6,5]
state2 = [1,8,2,0,4,3,7,6,5]

if isSolvable(state1):
  print('Solvable')
  print(state1)
  print('Solution:')
  possiblestate = solveByBFS(state1)
  print(len(possiblestate))
  print(possiblestate[-1])
else:
  print('No solution')

if isSolvable(state2):
  print('Solvable')
  print(state2)
  print('Solution:')
  possiblestate = solveByBFS(state2)
  print(len(possiblestate))
  print(possiblestate[-1])
else:
  print('No solution')

"""# **DFS Approach**"""

import numpy as np

def is_solvable(states: list[int])-> bool:
  inversion: int = 0
  for i in range(len(states)):
    for j in range(i + 1, len(states)):
      if states[i] > states[j] and states[j] != 0:
        inversion += 1
  return inversion % 2 == 0

def get_moves(state: list[int]) -> list[list[int]]:
    empty_tile_index = state.index(0)
    moves = []

    if empty_tile_index not in [0, 1, 2]:  # Can move UP
        new_state = state.copy()
        new_state[empty_tile_index], new_state[empty_tile_index - 3] = new_state[empty_tile_index - 3], new_state[empty_tile_index]
        moves.append(new_state)

    if empty_tile_index not in [6, 7, 8]:  # Can move DOWN
        new_state = state.copy()
        new_state[empty_tile_index], new_state[empty_tile_index + 3] = new_state[empty_tile_index + 3], new_state[empty_tile_index]
        moves.append(new_state)

    if empty_tile_index not in [0, 3, 6]:  # Can move LEFT
        new_state = state.copy()
        new_state[empty_tile_index], new_state[empty_tile_index - 1] = new_state[empty_tile_index - 1], new_state[empty_tile_index]
        moves.append(new_state)

    if empty_tile_index not in [2, 5, 8]:  # Can move RIGHT
        new_state = state.copy()
        new_state[empty_tile_index], new_state[empty_tile_index + 1] = new_state[empty_tile_index + 1], new_state[empty_tile_index]
        moves.append(new_state)

    return moves

def dfs_solve(state: list[int]):
    target = [1, 2, 3, 4, 5, 6, 7, 8, 0]
    stack = [state]
    visited_states = set()

    while stack:
        current_state = stack.pop()
        visited_states.add(tuple(current_state))

        if current_state == target:
            return current_state

        for next_state in get_moves(current_state):
            if tuple(next_state) not in visited_states:
                stack.append(next_state)

    return None

# Example states
state1 = [8, 1, 2, 0, 4, 3, 7, 6, 5]
state2 = [1, 8, 2, 0, 4, 3, 7, 6, 5]

if is_solvable(state1):
    print('Solvable')
    solution = dfs_solve(state1)
    if solution:
        print('Solution found:', solution)
    else:
        print('No solution found')
else:
    print('No solution')

if is_solvable(state2):
    print('Solvable')
    solution = dfs_solve(state2)
    if solution:
        print('Solution found:', solution)
    else:
        print('No solution found')
else:
    print('No solution')